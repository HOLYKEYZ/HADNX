"""
Scope Validator - Security control for exploitation framework.
Ensures only authorized admin can use exploitation features.
Admin identity stored securely in environment variable.
"""
import os
import hashlib
import logging
from urllib.parse import urlparse
from typing import Optional, Tuple
from django.conf import settings

logger = logging.getLogger(__name__)

class ScopeValidator:
    """
    Validates that:
    1. User is the authorized exploitation admin
    2. Target domain is in user's whitelist
    """
    
    # Read admin email from environment variable (NOT hardcoded)
    # Set EXPLOITATION_ADMIN_EMAIL in .env file
    ADMIN_EMAIL_ENV_KEY = 'EXPLOITATION_ADMIN_EMAIL'
    
    @classmethod
    def get_admin_email(cls) -> Optional[str]:
        """Get admin email from environment (secure, not in source code)."""
        return os.environ.get(cls.ADMIN_EMAIL_ENV_KEY)
    
    @classmethod
    def is_exploitation_admin(cls, user) -> bool:
        """
        Check if user is the authorized exploitation admin.
        Admin email must be set in .env as EXPLOITATION_ADMIN_EMAIL
        """
        if not user or not user.is_authenticated:
            return False
        
        admin_email = cls.get_admin_email()
        if not admin_email:
            logger.warning("EXPLOITATION_ADMIN_EMAIL not set in environment!")
            return False
        
        # Case-insensitive email comparison
        return user.email.lower() == admin_email.lower()
    
    @classmethod
    def is_authorized(cls, url: str, user=None) -> Tuple[bool, str]:
        """
        Check if exploitation is authorized for this URL and user.
        
        Returns:
            (is_authorized, reason)
        """
        parsed = urlparse(url)
        domain = parsed.netloc.lower()
        
        # 1. Must have authenticated user
        if not user or not user.is_authenticated:
            return False, "Authentication required for exploitation"
        
        # 2. Must be the exploitation admin
        if not cls.is_exploitation_admin(user):
            logger.warning(f"User {user.email} attempted exploitation but is not admin")
            return False, "Exploitation features are restricted to authorized administrators only"
        
        # 3. Get admin's authorized domains
        authorized_domains = getattr(user, 'authorized_domains', []) or []
        
        if not authorized_domains:
            return False, "No authorized domains configured. Add domains in Settings."
        
        # 4. Check exact match
        if domain in authorized_domains:
            logger.info(f"Domain {domain} authorized for admin {user.username}")
            return True, "Domain is in authorized list"
        
        # 5. Check wildcard subdomains (*.example.com)
        for auth_domain in authorized_domains:
            if auth_domain.startswith('*.'):
                base_domain = auth_domain[2:]  # Remove *.
                if domain.endswith('.' + base_domain) or domain == base_domain:
                    logger.info(f"Subdomain {domain} matches wildcard {auth_domain}")
                    return True, f"Matches wildcard pattern {auth_domain}"
        
        # 6. Localhost always allowed for testing (security: still requires admin)
        if domain in ['localhost', '127.0.0.1', '::1'] or domain.startswith('localhost:'):
            logger.info(f"Localhost domain {domain} automatically authorized for admin")
            return True, "Localhost is automatically authorized"
        
        logger.warning(f"Domain {domain} NOT authorized for admin {user.username}")
        return False, f"Domain {domain} is not in your authorized list"
    
    @classmethod
    def validate_or_raise(cls, url: str, user=None):
        """Validate scope or raise exception."""
        is_auth, reason = cls.is_authorized(url, user)
        if not is_auth:
            raise PermissionError(f"Exploitation not authorized: {reason}")


def is_exploitation_admin(user) -> bool:
    """Helper function to check admin status."""
    return ScopeValidator.is_exploitation_admin(user)
